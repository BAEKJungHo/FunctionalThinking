# 함수형 인프라스트럭처

불변성을 위한 함수형 인프라스트럭처 설계방법

- 모든 필드를 final로 선언한다.
  - final로 선언된 필드들은 선언 시나 생성자 내부에서 초기화해야 한다.
- 클래스를 final로 선언해서 오버라이드를 방지하라
  - 클래스가 오버라이드 되면 메서드들도 오버라이드 될 수 있다.
  - 클래스를 final로 생성해서 오버라이드를 막는다.
- 인수가 없는 생성자를 제공하지 말라
  - 불변형 객체의 모든 상태는 생성자가 정해야 한다.
- 적어도 하나의 생성자를 제공하라
  - 인수가 없는 생성자가 없으므로 객체에 상태를 더할 수 있는 마지막 기회를 제공해야 한다.
- 생성자 외에는 변이 메서드를 제공하지 말라
  - 자바빈스식 setXXX 메서드를 제공하지 않아야 하는 것은 물론이고, 가변 객체의 참조를 리턴하지 않게 조심해야 한다.
  
## 불변형 Client 클래스

```java
@Immutable
class Client {
  String name, city, state, zip;
  String[] streets;
}
```

`@Immutable` 어노테이션을 달면 이 클래스는 다음과 같은 특성을 갖는다.

- 이 클래스는 final로 선언된다.
- 모든 속성은 자동적으로 get 메서드가 딸린 비공개 필드를 가지게 된다.
- 이 속성을 업데이트하려고하면 ReadOnlyPropertyException이 발생한다.
  - 컬렉션 클래스들은 적합한 래퍼로 래핑되고, 배열이나 다른 복제 가능한 객체들은 복제된다.
- 디폴트 equals(), hashcode(), toString() 메서드가 자동 생성된다.

@Immutable 애너테이션은 이 책에서 반복되는 테마, 즉 '런타임에 상세한 구현을 양도하라' 를 잘 드러내 보여준다.

> 객체-관계형 매퍼 같은 도구들은 대부분의 경우에 불변 객체를 가정하기 때문에 가변 객체를 사용하면 비효울적이 되거나 작동하지 않는다.

## 명령-쿼리 간 책임 분리(QORS)

- 전통적인 애플리케이션 아키텍처
  - 관계형 DB <> 모델 <> 컨트롤러 <> 유저 인터페이스

- CORS
  - 읽기와 명령 부분을 분리
  
CORS는 읽기와 명령 부분을 분리함으로써 아키텍처의 일부를 단순화한다.

아키텍처는 항상 트레이드오프를 염두에 두어야 한다. CORS로 인해 한 부분은 쉬워지지만 다른 부분은 복잡해진다.

예를 들어 한 덩어리인 데이터베이스를 사용하면 트랜잭션이 쉽다. CORS를 사용하면 트랜잭션형보다는 최종 일관성 모델로 전환해야 할 것이다.

트랜잭션 모델이 ACID(원자성, 일관성, 고립성, 지속성)에 의존하는 반면, 최종 일관성 모델은 BASE(기본 가용성, 부드러운 상태, 최종 일관성)를 
중요하게 여긴다.

CORS는 모든 애플리케이션의 상태 변를 이벤트 스트림으로 보존해야 하는 `이벤트 소싱(event sourcing)`과 같은 아키텍처 패턴에 아주 적합하다.
